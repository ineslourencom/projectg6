#US09 Read Me
Sequence diagram and class diagram can be found on the folder US009, under documentation.
SVG and SPP formats were uploaded for better visualization.
![US009_SD](US09_SD_20210106.svg)
![US009_CD](US09_CD_20220109.svg)

##Entry Notes
As recommended by the PO, this phase of the project does not contemplate a UI, therefore
no data input validations are made to the class "CreateUserStoryUI". 
Since this class is empty (for now) it cannot be found on our repository at this moment. 

> Let's now follow all steps of the Sequence diagram (SD). 


## Step 1 - Starts new US
The user logged into the system will initiate the action of creating a new US.
This will trigger a series of events and those will result in a list of Projects which 
the logged user owns with the resource role of Product Owner (PO).

## Step 1.1 - listPOsProjects(email:String):List<String>
The controller redirects the ask of listing the POs projectStore to the class "ITCompany",
which is our information expert (IE) class. It then redirects the profileRequest to "Projects",
which in turn is the class that "knows" all the projectStore.

**Tests:**
* **listPOsProjects** -> this test verifies if the list created by calling the controller class 
method and the ITCompany class method are the same, which they are expected to be.

## Step 1.1.1 - listPOsProjects(email:String):List<String>
The ITCompany, our infomation expert, will then ask the class "Projects" to provide it a filtered list
of Projects, which shows only the ones of which the user logged is a PO.

**Tests:**
* **listPOsProjectsSize1** -> After adding one project to the listOfPOsProjects and 
one resource (PO) to its project team (via beforeAll) we shall have 1 project in the list.
Hence, the expected list size shall have one more item than before this test was run. 

* **listPOsProjectsSize2** -> After adding another project to the projectsList and
another resource (PO) to its project team we shall have 2 projectStore in the list (the PO owns two projectStore).

* **listPOsProjectsWhereNotAllResourcesArePO** -> We add a new resource, which is not a PO, to an 
already existing project (project2). Since we have three resourceStore, two associated with the same project but with different roles,
one of them is not a pO, we shall have as result a list with two projectStore only.

## Step 1.1.1.1 - listPOsProjects(email:String):List<String>
This method will run through all known projectStore and check if each of their project teams contain
a resource which: is PO, its end date is not yet defined or happens somewhere in the future, its user
account matches the email passed as argument.
Whenever a project that meets these conditions is found, it will be added to a newly created list of projectStore.
Finally, and in order not to violate the encapsulation principle, that list is copied over to a 
list of Strings, by using the "toString" method, which converts each object "Project" into 
a string with an ID and name.

**Tests**
* **addToListOfPOsProjects** ->
Arrange: Create a list of projectStore. Create 2 new projectStore. Add them to the list created initially.
Create one new resource with the role of PO and it to one of the projectStore mentioned earlier.
Act: calculate the size of the list generated by the method mentioned in 1.1.1.1.
Assert: assert the size of the list to "1", because only one of the projectStore created has a resource who
currently plays the role of a PO in it. 
* **addMultipleProjectsToListOfPOsProjects** -> does exactly the same as the previous test, but this time we add three 
projectStore to the list and two resourceStore with the role of PO.
* **listProjects** -> Arrange: we create three projectStore, add them to a list of projectStore, then we create to resourceStore
with the role of Product Owner and associate them to two of the projectStore.
Act: get the projectStore in position 0 and 1 from the list generated by the method mentioned in 1.1.1.1
Assert: we check if the strings gotten equal the expected result. 

## Step 1.1.1.1.1 - check1 = isProjectOwnedByPO(email) : boolean
This method goes through all resourceStore in a certain project team to understand if one of them is a PO
associated with the account identified by the parameter "email". If such condition is met, a true/false message is 
thrown. 

**Tests**
* **isProjectOwnedByPO** -> Arrange: create a project, create two resourceStore and add them both to the project's team.
Act: run the method mentioned in 1.1.1.1.1 for the project created in the arrange. 
Assert: the result of the act must be true, because one resource with the role of PO was associated to the mentioned 
* project. 

##Step 1.1.1.1.1.1. isResourceProjectsActivePO(String email, int code) : boolean
Method to verify if a certain resource has the role of PO of a certain project and the user is identified by the email passed as parameter.
This is only true, if the resource is active, i.e., if its end date is empty or somewhere in the future.

**Tests**
Arrange: done in separate class, where we generate a series of projectStore, and resourceStore for the purpose of testing.
(common to all tests)
* **isResourceProjectsActivePO** -> 
Act: the method mentioned in 1.1.1.1.1.1 is called.
Assert: the method must return true, because we have created resourceStore with the role of PO which are still active.
  (... we test other not success cases, like wrong project, wrong email, not active resource, etc.)


##Step 1.1.1.1.1.1.1: check3 = isAccountEqualTo(email) : boolean
Method used to verify if a certain account is the same as the one identified by an email passed as parameter.
Returns true/false.

**Tests**
* **areAccountsDifferent** -> checks if two different accountStore (identified by the different emails) are the same.
* **areAccountsSame** -> checks if two same accountStore (identified by the same email) are the same.

##Step 1.1.1.1.1.1.3: isRolePO() : boolean
Verifies if a certain ResourceRole is Product Owner.
**Tests**
* **isRolePO** -> checks if the role of a ResourceRole created as PO is indeed PO. 
* **isRoleNotPO** -> checks if the role of a ResourceRole created as Project Manager is PO. (must return false)

##Step 1.1.1.1.1.3.1.1: addToListOfPOsProjects(email : String) : List<String>
See step 1.1.1.1

## Step 2: types input data and selects project
Here the user will type the needed information to create a User Story (US) and select a project out of the list
returned by 1.1.1.1.1.3.1.2.1.1: listOfPOsProjectsString.
This will trigger a series of events and those will result in a new US added to a product Backlog.

## Step  2.1: createUserStory(description, detail, code) : boolean
The controller redirects the ask of creating a US to the class "ITCompany",
which is our information expert (IE) class. It then redirects the profileRequest to "Projects",
which in turn is the class that "knows" all the projectStore and gets the object that corresponds to the code passed as
argument in this method. 
The controller will also redirect the responsibility of creating a US to the class Product Backlog, which is our Creator class.
This happens because the product is the class that knows all US of a certain project. However, a stop must be done in 
the class Project, due to the navigability way shown in the class diagram (CD).

**Tests**
* **createUserStory** -> here we just check if the method above returns true when creating a US, which meands that the 
US was successfully created.

##Step 2.1.1: getProject(code) : Project
Method to return the object project that is identified by the code passed as argument.
We understand that this method may be seen as violating the encapsulation, but however we are returning a object
that needs to be passed back to the controller. 

**Tests**
* **getProject** -> In this test we get a project using the method in the class ITCompany and the same project using
method in the class controller. Finally we verify if they are equal. Note that this class Model has all testing objects
arranged in the begining of the class. 

## Step 2.1.1.1: findProject(code) : Project
Searches the list of projectStore for a project with given code.
@param code identifies the project to find. 
@return project with given code.
In case the project is not found in the given list, an exception is thrown.
We understand that this method may be seen as violating the encapsulation, but however we are returning a object
that needs to be passed back to the controller.

**Tests**
* **testFindProjectThatExists** -> Arrange: creates lists of projectStore, adds projectStore to lists. Act: run method for list "One".
Assert: check if the project found is the same as the one created in the arrange (they must be).
* **testFindProjectThatDoesNotExist** -> Arrange: creates lists of projectStore, adds projectStore to lists. Act/assert: tries
to find a project with a code that does not exist (was not created in the arrange).

## Step 2.1.1.1.1: hasId(code) : boolean
Verifies if project Id is equal to the id parameter.
@param id value to compare to project Id.
@return true if values are equal.

**Tests**
* **testProjectIdForActualId** -> Ensures return is true for correct Id
* **testProjectIdForWrongId** -> Ensures return is false for incorrect Id

## Step 2.1.3: createUserStory(detail, description) : UserStory
Method to create US. The method calls the attribute of project "productBacklog", following the navigabiliity shown in
the CD, and its method "createUserStory". the product Backlog is considered the creator of a US.
We understand that this method may be seen as violating the encapsulation, but however we are returning a object
that needs to be passed back to the controller and which is being created by this method.

**Tests**
* **createUserStory** -> This test checks if the US created using the constructor equals the one created using the 
method above, when passing the same "detail" and "description". They must be equal to pass the test. 

## Step 2.1.3.1: createUserStory(detail, description) : UserStory
Method to create a new US. As explained before, Productbacklog is the class with that responsibility (creator), because
he knows all US of a given project.
Before creating the US, a validation is done, namely, it doesn't let a US to be created if there is already another
one linked to that project with the same description, i.e., the US must be unique. In case that step is passed, the 
method will also generate a code for the US, based on the already existing USs in the Backlog.
Immediately after, the constructor is called and the US is created. 

**Tests**
* **createUserStory** -> This test checks if two USs created using the same constructor and with the same attributes
(detail and description) equal each other. They must be equal to pass the test. 
* **createUserStoryDifferentCode** -> Two user stories may have the same details and descriptions, and still be different.
This happens, because they belong to different products backlogs, they have different codes, and therefore they are different.
The test must verify that these two userStories are different.
* **createUserStorySameDescription** -> We must not be able to create a US that has the same description of another one
in the product backlog.

## Step 2.1.3.1.1: validateUSDescription(description) : boolean
Method to validate the description entered by the user.
Two US of the same project (i.e. product backlog) must not have the same description.

**Tests**
* **validateUSDescription** -> If there is already a US with description "US09" in the product backlog, we must not be
  able to add another one with the same description, so the validation method must return "false".

## Step 2.1.3.1.2: generateUserStoryNumber() : int
Method to generate a code for the US being created.
The code generator will start with code=1 and for each object UserStory of the list (attribute of BAcklog) it will ask
the class UserStory if its code is higher or equal to the code passed. If not, that code is used for that UserStory.
This method was created in the class ProductBacklog because it is the Creator and the one who knows all the US 
associated with a project, which is essential to determine a sequential UserStory number. 

**Tests**
* **generateUserStoryNumber** -> After adding one US to the productBacklog, the US created afterwards must have code = 2. 

## Step 2.1.3.1.3: newUS = userStory(storyNumber, description, detail) : UserStory
Constructor without registering the creator - not needed for now as recommended by PO. Note that the userStory 
doesn't contain the ProductBacklog linked to it, because we can get the USs of a certain ProductBacklog by 
checking its attribute "userStoryList".
This US validates that the strings passed as parameters are not empty or filled with spaces. It also validates both
the detail and description sizes. 

**Tests**
* **testIsEmptyInputsOnUSConstructor** -> this test must throw an exception is the parameter description passed
is empty
* **testsEmptyInputsOnUSConstructor** -> this test must throw an exception is the parameter detail passed is empty

##Step 2.1.3.1.4: isUSToBeAddedValid(newUS) : boolean
A US can't be added to a ProductBacklog if it is already there OR if the US is null.

**Tests**
This method is tested indirectly as shown in the following step.

##Step  2.1.3.1.5: addUserStory(newUS) : boolean
Adds the newly created US to the respective productBacklog, unless the previous method returns false, i.e, the 
US is not unique in that project or the object is null. 

**Tests**
* **newSizeAfterAddingUSToProductBacklogList** -> After adding a US to the product backlog list, its size must increase
one unit. This means, its initialLength+1=finalLength. The test returns true if this is verified. 
* **addRepeatedUserStory** -> If we try to add two equal USs to the same productBacklog, the test will throw an exception.
* **addNullUserStory** -> If we try to add a null US to the same productBacklog, the test will throw an exception.
  


**Tests Coverage:**
UserStory class: 94%
ProductBacklog class: 100%
CreateUserStoryController: 100%
Note - mutations were not run due to problems in tests of the class Model which are to be solved earlier next week
with the support of the teachers. 
We understand that the problem is we are working with real data and therefore the tests must be run in sequential order.
This is to be fixed soon. 

